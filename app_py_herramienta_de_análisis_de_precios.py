# -*- coding: utf-8 -*-
"""app.py - Herramienta de An치lisis de Precios

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DPP79BQ6-f-pk24zMj8Z4JEOCsw1O2SQ
"""

import streamlit as st
import pandas as pd
import plotly.express as px
import re
from datetime import datetime

# --- Configuraci칩n de la P치gina de Streamlit ---
st.set_page_config(
    layout="wide",
    page_title="An치lisis de Precios SERP",
    page_icon="游늳"
)

# --- Funciones de Procesamiento de Datos ---

@st.cache_data # Cache para mejorar el rendimiento. No se reprocesa si los archivos no cambian.
def load_and_process_data(uploaded_files):
    """
    Carga, une y limpia los datos de los archivos CSV subidos.
    Esta funci칩n est치 adaptada a la estructura de tus archivos.
    """
    if not uploaded_files:
        return pd.DataFrame(), pd.DataFrame()

    all_data = []
    for file in uploaded_files:
        try:
            df = pd.read_csv(file)
            # --- Procesamiento de Fecha ---
            # Convierte la columna 'fecha' (formato DDMMAA) a un objeto de fecha real.
            # `errors='coerce'` convertir치 fechas inv치lidas en NaT (Not a Time).
            df['fecha'] = pd.to_datetime(df['fecha'], format='%d%m%y', errors='coerce')
            all_data.append(df)
        except Exception as e:
            # Notifica al usuario si un archivo no se puede procesar.
            st.warning(f"No se pudo procesar el archivo {file.name}: {e}")
            continue

    if not all_data:
        return pd.DataFrame(), pd.DataFrame()

    # Unir todos los DataFrames de los archivos en uno solo.
    full_df = pd.concat(all_data, ignore_index=True)

    # --- Limpieza de Datos ---
    # Eliminar filas donde la fecha no se pudo convertir.
    full_df.dropna(subset=['fecha'], inplace=True)

    # Limpiar columna de precio (formato: $ 150.999,00)
    if 'precio' in full_df.columns:
        # 1. Convertir a string para asegurar que los m칠todos .str funcionen.
        # 2. Eliminar el s칤mbolo '$' y los puntos de miles.
        # 3. Reemplazar la coma decimal por un punto.
        # 4. Convertir la columna a tipo num칠rico.
        # 5. `errors='coerce'` manejar치 cualquier valor que no se pueda convertir.
        price_series = full_df['precio'].astype(str)
        price_series = price_series.str.replace(r'[$.]', '', regex=True).str.replace(',', '.', regex=False)
        full_df['precio'] = pd.to_numeric(price_series, errors='coerce')

    # Limpiar dominio (aunque ya est치 limpio, es una buena pr치ctica).
    if 'dominio' in full_df.columns:
         full_df['dominio'] = full_df['dominio'].astype(str).str.strip()

    # Eliminar filas donde el precio es nulo despu칠s de la limpieza.
    full_df.dropna(subset=['precio'], inplace=True)

    # --- C치lculo de Precios M칤nimos ---
    # Para cada producto y fecha, encuentra el precio m칤nimo.
    # `transform('min')` crea una nueva columna con el precio m칤nimo para ese grupo.
    full_df['precio_minimo'] = full_df.groupby(['fecha', 'producto'])['precio'].transform('min')
    # Marca las filas que tienen el precio m치s bajo.
    full_df['es_precio_mas_bajo'] = full_df['precio'] == full_df['precio_minimo']

    return full_df


# --- T칤tulo y Descripci칩n de la App ---
st.title("游늳 Herramienta Interactiva de An치lisis de Precios")
st.markdown("""
Sube los archivos CSV de tus relevos de precios para visualizar y analizar las tendencias del mercado.
Esta herramienta te permitir치:
- Rastrear la evoluci칩n de tus precios y los de la competencia.
- Identificar qu칠 competidores tienen las estrategias de precios m치s agresivas.
- Filtrar los datos por producto, competidor, rango de fechas y nivel de precio.
""")

# --- Barra Lateral (Sidebar) para Controles y Filtros ---
with st.sidebar:
    st.header("丘뙖잺 Filtros y Controles")
    uploaded_files = st.file_uploader(
        "1. Carga tus archivos CSV",
        type=['csv'],
        accept_multiple_files=True,
        help="Puedes seleccionar m칰ltiples archivos de relevo. La app los combinar치 autom치ticamente."
    )

    if not uploaded_files:
        st.info("Por favor, sube al menos un archivo CSV para comenzar el an치lisis.")
        st.stop()

    # Cargar y procesar los datos usando la funci칩n cacheada.
    df = load_and_process_data(uploaded_files)

    if df.empty:
        st.error("No se pudieron cargar datos v치lidos de los archivos. Revisa el formato de los CSV.")
        st.stop()

    st.success(f"{len(df)} registros cargados de {len(uploaded_files)} archivos.")

    # --- Filtros Din치micos ---
    # Los filtros se basan en los datos cargados.

    # 2. Filtro de Rango de Fechas
    min_date = df['fecha'].min().date()
    max_date = df['fecha'].max().date()

    selected_date_range = st.date_input(
        "2. Selecciona un Rango de Fechas",
        value=(min_date, max_date),
        min_value=min_date,
        max_value=max_date,
        help="Selecciona el per칤odo que quieres analizar."
    )

    # 3. Filtro de Productos
    all_products = sorted(df['producto'].unique())
    selected_products = st.multiselect(
        "3. Selecciona Productos",
        options=all_products,
        default=all_products, # Por defecto, todos seleccionados
        help="Elige los productos para incluir en el an치lisis."
    )

    # 4. Filtro de Competidores
    all_domains = sorted(df['dominio'].unique())
    selected_domains = st.multiselect(
        "4. Selecciona Competidores",
        options=all_domains,
        default=all_domains, # Por defecto, todos seleccionados
        help="Elige los dominios para incluir en los gr치ficos."
    )

    # 5. Filtro de Nivel de Precio
    all_price_levels = df['price_level'].unique()
    selected_price_levels = st.multiselect(
        "5. Filtra por Nivel de Precio",
        options=all_price_levels,
        default=all_price_levels, # Por defecto, todos seleccionados
    )

# --- Filtrado del DataFrame Principal ---
# Se aplican los filtros de la barra lateral al DataFrame.
# Asegurarse que el rango de fechas sea de dos valores.
if len(selected_date_range) == 2:
    start_date, end_date = selected_date_range
    filtered_df = df[
        (df['fecha'].dt.date >= start_date) &
        (df['fecha'].dt.date <= end_date) &
        (df['producto'].isin(selected_products)) &
        (df['dominio'].isin(selected_domains)) &
        (df['price_level'].isin(selected_price_levels))
    ]
else:
    # Si el usuario solo selecciona una fecha, se usa solo esa.
    filtered_df = df[df['fecha'].dt.date == selected_date_range[0]]


# --- Panel Principal de Visualizaciones ---
st.header("游늵 Visualizaci칩n de Datos")

if filtered_df.empty:
    st.warning("No hay datos para mostrar con los filtros seleccionados. Por favor, ajusta los filtros.")
else:
    # --- Gr치fico 1: Evoluci칩n de Precios ---
    st.subheader("1. Evoluci칩n de Precios por Producto")

    # Si hay muchos productos, hacer un gr치fico por cada uno es mejor.
    # Si hay pocos, se pueden poner en un solo gr치fico.
    if len(selected_products) > 1:
        # Crea un gr치fico separado (facet) para cada producto.
        fig_evolucion = px.line(
            filtered_df,
            x='fecha',
            y='precio',
            color='dominio',
            facet_row='producto', # Clave para separar por producto
            markers=True,
            title="Evoluci칩n de Precios a lo Largo del Tiempo (por Producto)"
        )
        fig_evolucion.update_layout(height=300 * len(selected_products)) # Ajustar altura
        fig_evolucion.update_yaxes(matches=None, title="Precio (AR$)") # Escalas Y independientes
    else:
        # Gr치fico simple si solo se selecciona un producto.
        fig_evolucion = px.line(
            filtered_df,
            x='fecha',
            y='precio',
            color='dominio',
            markers=True,
            title=f"Evoluci칩n de Precios para: {selected_products[0]}" if selected_products else "Evoluci칩n de Precios"
        )
        fig_evolucion.update_yaxes(title="Precio (AR$)")

    st.plotly_chart(fig_evolucion, use_container_width=True)

    # --- Gr치fico 2: Ranking de Competidores ---
    st.subheader("2. Ranking de Competidores con Precios Bajos")

    # Contar cu치ntas veces cada dominio tuvo el precio m치s bajo.
    lowest_price_counts = filtered_df[filtered_df['es_precio_mas_bajo']]['dominio'].value_counts().reset_index()
    lowest_price_counts.columns = ['dominio', 'cantidad_precios_bajos']

    fig_ranking = px.bar(
        lowest_price_counts,
        x='dominio',
        y='cantidad_precios_bajos',
        color='dominio',
        title="Frecuencia con la que un Competidor Ofrece el Precio M치s Bajo",
        labels={'dominio':'Competidor', 'cantidad_precios_bajos':'N췈 de Veces con Precio M치s Bajo'}
    )
    st.plotly_chart(fig_ranking, use_container_width=True)

    # --- Gr치fico 3: Comparativa en un D칤a Espec칤fico ---
    st.subheader("3. Comparativa de Precios en un D칤a Espec칤fico")

    # Permitir al usuario seleccionar una fecha y un producto para un an치lisis detallado.
    col1, col2 = st.columns(2)
    with col1:
        selected_date_for_bar = st.selectbox(
            "Selecciona una Fecha",
            sorted(filtered_df['fecha'].dt.date.unique(), reverse=True)
        )
    with col2:
        selected_product_for_bar = st.selectbox(
            "Selecciona un Producto",
            selected_products
        )

    snapshot_df = filtered_df[
        (filtered_df['fecha'].dt.date == selected_date_for_bar) &
        (filtered_df['producto'] == selected_product_for_bar)
    ].sort_values('precio')

    if not snapshot_df.empty:
        fig_snapshot = px.bar(
            snapshot_df,
            x='dominio',
            y='precio',
            color='dominio',
            title=f"Precios para '{selected_product_for_bar}' el {selected_date_for_bar}",
            labels={'dominio':'Competidor', 'precio':'Precio (AR$)'},
            text='precio' # Muestra el valor del precio en la barra
        )
        fig_snapshot.update_traces(texttemplate='$%{text:,.0f}', textposition='outside')
        st.plotly_chart(fig_snapshot, use_container_width=True)
    else:
        st.info(f"No hay datos para '{selected_product_for_bar}' en la fecha seleccionada.")


    # --- Expander para ver los datos crudos ---
    with st.expander("Ver tabla de datos filtrados"):
        st.dataframe(filtered_df.drop(columns=['precio_minimo', 'es_precio_mas_bajo']).style.format({'precio': "AR$ {:,.2f}"}))